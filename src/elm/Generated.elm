
-- generated by elm_rs


module Generated exposing (..)

import Dict exposing (Dict)
import Http
import Json.Decode
import Json.Encode
import Url.Builder


resultEncoder : (e -> Json.Encode.Value) -> (t -> Json.Encode.Value) -> (Result e t -> Json.Encode.Value)
resultEncoder errEncoder okEncoder enum =
    case enum of
        Ok inner ->
            Json.Encode.object [ ( "Ok", okEncoder inner ) ]
        Err inner ->
            Json.Encode.object [ ( "Err", errEncoder inner ) ]


resultDecoder : Json.Decode.Decoder e -> Json.Decode.Decoder t -> Json.Decode.Decoder (Result e t)
resultDecoder errDecoder okDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map Ok (Json.Decode.field "Ok" okDecoder)
        , Json.Decode.map Err (Json.Decode.field "Err" errDecoder)
        ]


type ModelId
    = ModelId (Int)


modelIdEncoder : ModelId -> Json.Encode.Value
modelIdEncoder (ModelId inner) =
    (Json.Encode.int) inner


type ValueInner
    = Integer (Int)
    | Double (Float)
    | String (String)
    | Symbol (String)
    | Stl (ModelId)
    | List (List (ValueInner))


valueInnerEncoder : ValueInner -> Json.Encode.Value
valueInnerEncoder enum =
    case enum of
        Integer inner ->
            Json.Encode.object [ ( "t", Json.Encode.string "Integer"), ( "c", Json.Encode.int inner ) ]
        Double inner ->
            Json.Encode.object [ ( "t", Json.Encode.string "Double"), ( "c", Json.Encode.float inner ) ]
        String inner ->
            Json.Encode.object [ ( "t", Json.Encode.string "String"), ( "c", Json.Encode.string inner ) ]
        Symbol inner ->
            Json.Encode.object [ ( "t", Json.Encode.string "Symbol"), ( "c", Json.Encode.string inner ) ]
        Stl inner ->
            Json.Encode.object [ ( "t", Json.Encode.string "Stl"), ( "c", modelIdEncoder inner ) ]
        List inner ->
            Json.Encode.object [ ( "t", Json.Encode.string "List"), ( "c", Json.Encode.list (valueInnerEncoder) inner ) ]

type alias Evaled =
    { value : ValueInner
    , previewList : List (ModelId)
    }


evaledEncoder : Evaled -> Json.Encode.Value
evaledEncoder struct =
    Json.Encode.object
        [ ( "value", (valueInnerEncoder) struct.value )
        , ( "preview_list", (Json.Encode.list (modelIdEncoder)) struct.previewList )
        ]


type FromElmMessage
    = EvalCode { code : String }
    | GetStlBytes { modelId : Int }
    | LoadFile { filePath : String }


fromElmMessageEncoder : FromElmMessage -> Json.Encode.Value
fromElmMessageEncoder enum =
    case enum of
        EvalCode { code } ->
            Json.Encode.object [ ( "type", Json.Encode.string "EvalCode" ), ( "code", (Json.Encode.string) code ) ]
        GetStlBytes { modelId } ->
            Json.Encode.object [ ( "type", Json.Encode.string "GetStlBytes" ), ( "model_id", (Json.Encode.int) modelId ) ]
        LoadFile { filePath } ->
            Json.Encode.object [ ( "type", Json.Encode.string "LoadFile" ), ( "file_path", (Json.Encode.string) filePath ) ]

type ToElmMessage
    = EvaluationResult { result : Result (String) (Evaled) }
    | StlBytes { modelId : Int, bytes : List (Int) }
    | FileLoaded { path : String, content : String }
    | FileLoadError { error : String }
    | Error { message : String }


toElmMessageEncoder : ToElmMessage -> Json.Encode.Value
toElmMessageEncoder enum =
    case enum of
        EvaluationResult { result } ->
            Json.Encode.object [ ( "type", Json.Encode.string "EvaluationResult" ), ( "result", (resultEncoder (Json.Encode.string) (evaledEncoder)) result ) ]
        StlBytes { modelId, bytes } ->
            Json.Encode.object [ ( "type", Json.Encode.string "StlBytes" ), ( "model_id", (Json.Encode.int) modelId ), ( "bytes", (Json.Encode.list (Json.Encode.int)) bytes ) ]
        FileLoaded { path, content } ->
            Json.Encode.object [ ( "type", Json.Encode.string "FileLoaded" ), ( "path", (Json.Encode.string) path ), ( "content", (Json.Encode.string) content ) ]
        FileLoadError { error } ->
            Json.Encode.object [ ( "type", Json.Encode.string "FileLoadError" ), ( "error", (Json.Encode.string) error ) ]
        Error { message } ->
            Json.Encode.object [ ( "type", Json.Encode.string "Error" ), ( "message", (Json.Encode.string) message ) ]

modelIdDecoder : Json.Decode.Decoder ModelId
modelIdDecoder =
    Json.Decode.map ModelId (Json.Decode.int)


valueInnerDecoder : Json.Decode.Decoder ValueInner
valueInnerDecoder = 
    Json.Decode.field "t" Json.Decode.string
        |> Json.Decode.andThen
            (\tag ->
                case tag of
                    "Integer" ->
                        Json.Decode.map Integer (Json.Decode.field "c" (Json.Decode.int))
                    "Double" ->
                        Json.Decode.map Double (Json.Decode.field "c" (Json.Decode.float))
                    "String" ->
                        Json.Decode.map String (Json.Decode.field "c" (Json.Decode.string))
                    "Symbol" ->
                        Json.Decode.map Symbol (Json.Decode.field "c" (Json.Decode.string))
                    "Stl" ->
                        Json.Decode.map Stl (Json.Decode.field "c" (modelIdDecoder))
                    "List" ->
                        Json.Decode.map List (Json.Decode.field "c" (Json.Decode.list (valueInnerDecoder)))
                    unexpected ->
                        Json.Decode.fail <| "Unexpected variant " ++ unexpected
            )

evaledDecoder : Json.Decode.Decoder Evaled
evaledDecoder =
    Json.Decode.succeed Evaled
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "value" (valueInnerDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "preview_list" (Json.Decode.list (modelIdDecoder))))


fromElmMessageDecoder : Json.Decode.Decoder FromElmMessage
fromElmMessageDecoder = 
        let
            elmRsConstructEvalCode code =
                        EvalCode { code = code }
            elmRsConstructGetStlBytes modelId =
                        GetStlBytes { modelId = modelId }
            elmRsConstructLoadFile filePath =
                        LoadFile { filePath = filePath }
        in
    Json.Decode.field "type" Json.Decode.string
        |> Json.Decode.andThen
            (\tag ->
                case tag of
                    "EvalCode" ->
                        Json.Decode.succeed elmRsConstructEvalCode |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "code" (Json.Decode.string)))
                    "GetStlBytes" ->
                        Json.Decode.succeed elmRsConstructGetStlBytes |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "model_id" (Json.Decode.int)))
                    "LoadFile" ->
                        Json.Decode.succeed elmRsConstructLoadFile |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "file_path" (Json.Decode.string)))
                    unexpected ->
                        Json.Decode.fail <| "Unexpected variant " ++ unexpected
            )

toElmMessageDecoder : Json.Decode.Decoder ToElmMessage
toElmMessageDecoder = 
        let
            elmRsConstructEvaluationResult result =
                        EvaluationResult { result = result }
            elmRsConstructStlBytes modelId bytes =
                        StlBytes { modelId = modelId, bytes = bytes }
            elmRsConstructFileLoaded path content =
                        FileLoaded { path = path, content = content }
            elmRsConstructFileLoadError error =
                        FileLoadError { error = error }
            elmRsConstructError message =
                        Error { message = message }
        in
    Json.Decode.field "type" Json.Decode.string
        |> Json.Decode.andThen
            (\tag ->
                case tag of
                    "EvaluationResult" ->
                        Json.Decode.succeed elmRsConstructEvaluationResult |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "result" (resultDecoder (Json.Decode.string) (evaledDecoder))))
                    "StlBytes" ->
                        Json.Decode.succeed elmRsConstructStlBytes |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "model_id" (Json.Decode.int))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "bytes" (Json.Decode.list (Json.Decode.int))))
                    "FileLoaded" ->
                        Json.Decode.succeed elmRsConstructFileLoaded |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "path" (Json.Decode.string))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "content" (Json.Decode.string)))
                    "FileLoadError" ->
                        Json.Decode.succeed elmRsConstructFileLoadError |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "error" (Json.Decode.string)))
                    "Error" ->
                        Json.Decode.succeed elmRsConstructError |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "message" (Json.Decode.string)))
                    unexpected ->
                        Json.Decode.fail <| "Unexpected variant " ++ unexpected
            )

