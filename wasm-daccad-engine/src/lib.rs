use elm_rs::{Elm, ElmDecode, ElmEncode};
use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::prelude::*;

mod env;
mod eval;
mod manifold_primitives;
mod parser;

pub use env::*;
pub use eval::*;
pub use parser::*;

// Message types defined below will be automatically exported

// Message types for Elm/TypeScript communication
#[derive(Debug, Clone, Serialize, Deserialize, Elm, ElmDecode, ElmEncode, Tsify)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(tag = "type")]
pub enum FromElmMessage {
    EvalCode { code: String },
    GetStlBytes { model_id: u64 },
    LoadFile { file_path: String },
}

#[derive(Debug, Clone, Serialize, Deserialize, Elm, ElmDecode, ElmEncode, Tsify)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(tag = "type")]
pub enum ToElmMessage {
    EvaluationResult {
        result: Result<eval::Evaled, String>,
    },
    StlBytes {
        model_id: u64,
        bytes: Vec<u8>,
    },
    FileLoaded {
        path: String,
        content: String,
    },
    FileLoadError {
        error: String,
    },
    Error {
        message: String,
    },
}

#[wasm_bindgen]
pub struct DaccadEngine {
    env: env::Env,
}

#[wasm_bindgen]
impl DaccadEngine {
    #[wasm_bindgen(constructor)]
    pub fn new() -> DaccadEngine {
        DaccadEngine {
            env: eval::default_env(),
        }
    }

    #[wasm_bindgen]
    pub fn eval_code(&mut self, code: &str) -> Result<JsValue, String> {
        let cub = manifold_primitives::js_create_cube(1.0, 1.0, 1.0); // Example call to JS function
        let manifold_object = manifold_primitives::get_and_parse_mesh_data(&cub)?;
        // Dummy implementation for future Prolog integration
        let _ = code;
        let dummy_result = eval::Evaled {
            value: ValueInner::String(format!(
                "Dummy evaluation result for code: {:?}",
                manifold_object
            )),
            preview_list: vec![],
        };
        Ok(serde_wasm_bindgen::to_value(&dummy_result).unwrap())
    }

    #[wasm_bindgen]
    pub fn clear_env(&mut self) {
        self.env = eval::default_env();
    }

    #[wasm_bindgen]
    pub fn handle_message(&mut self, message_json: &str) -> Result<String, String> {
        // Parse JSON message using strongly typed enum
        match serde_json::from_str::<FromElmMessage>(message_json) {
            Ok(message) => {
                let response = match message {
                    FromElmMessage::EvalCode { code } => {
                        let eval_result = self.eval_code(&code);
                        ToElmMessage::EvaluationResult {
                            result: eval_result
                                .map_err(|e| e.to_string())
                                .map(|v| eval::Evaled {
                                    value: ValueInner::String(format!("Evaled result: {:?}", v)),
                                    preview_list: vec![],
                                }),
                        }
                    }
                    FromElmMessage::GetStlBytes { model_id } => {
                        let bytes = self.get_mesh_stl_bytes(model_id as usize);
                        if let Some(bytes) = bytes {
                            ToElmMessage::StlBytes { model_id, bytes }
                        } else {
                            ToElmMessage::Error {
                                message: "Model not found".to_string(),
                            }
                        }
                    }
                    FromElmMessage::LoadFile { .. } => {
                        // LoadFile is handled in TypeScript layer
                        ToElmMessage::Error {
                            message: "LoadFile should be handled in TypeScript layer".to_string(),
                        }
                    }
                };

                serde_json::to_string(&response).map_err(|e| format!("Serialization error: {}", e))
            }
            Err(err) => Err(format!("Invalid JSON: {}", err)),
        }
    }

    #[wasm_bindgen]
    pub fn get_mesh_stl_bytes(&self, model_id: usize) -> Option<Vec<u8>> {
        match self.env.get_model(ModelId::from(model_id)) {
            Some(model) => match model {
                env::Model::Manifold(manifold) => Some(self.manifold_to_stl_bytes(manifold)),
                env::Model::Mesh(mesh) => Some(self.mesh_to_stl_bytes(mesh)),
                _ => None,
            },
            None => None,
        }
    }

    fn manifold_to_stl_bytes(&self, manifold: &env::ManifoldObject) -> Vec<u8> {
        self.mesh_to_stl_bytes(&env::MeshData {
            vertices: manifold.vertices.clone(),
            faces: manifold.faces.clone(),
        })
    }

    fn mesh_to_stl_bytes(&self, mesh: &env::MeshData) -> Vec<u8> {
        let mut bytes = Vec::new();

        // STL header (80 bytes)
        let header = format!("Generated by daccad model");
        let header_bytes = header.as_bytes();
        bytes.extend_from_slice(header_bytes);
        bytes.resize(80, 0); // Pad to 80 bytes

        // Number of triangles (4 bytes, little endian)
        let num_triangles = mesh.faces.len() as u32;
        bytes.extend_from_slice(&num_triangles.to_le_bytes());

        // Triangles
        for face in &mesh.faces {
            if face.len() >= 3 {
                let v0 = &mesh.vertices[face[0]];
                let v1 = &mesh.vertices[face[1]];
                let v2 = &mesh.vertices[face[2]];

                // Calculate normal vector (cross product)
                let edge1 = (v1.x - v0.x, v1.y - v0.y, v1.z - v0.z);
                let edge2 = (v2.x - v0.x, v2.y - v0.y, v2.z - v0.z);
                let normal = (
                    edge1.1 * edge2.2 - edge1.2 * edge2.1,
                    edge1.2 * edge2.0 - edge1.0 * edge2.2,
                    edge1.0 * edge2.1 - edge1.1 * edge2.0,
                );

                // Normal vector (12 bytes)
                bytes.extend_from_slice(&(normal.0 as f32).to_le_bytes());
                bytes.extend_from_slice(&(normal.1 as f32).to_le_bytes());
                bytes.extend_from_slice(&(normal.2 as f32).to_le_bytes());

                // Vertex 0 (12 bytes)
                bytes.extend_from_slice(&(v0.x as f32).to_le_bytes());
                bytes.extend_from_slice(&(v0.y as f32).to_le_bytes());
                bytes.extend_from_slice(&(v0.z as f32).to_le_bytes());

                // Vertex 1 (12 bytes)
                bytes.extend_from_slice(&(v1.x as f32).to_le_bytes());
                bytes.extend_from_slice(&(v1.y as f32).to_le_bytes());
                bytes.extend_from_slice(&(v1.z as f32).to_le_bytes());

                // Vertex 2 (12 bytes)
                bytes.extend_from_slice(&(v2.x as f32).to_le_bytes());
                bytes.extend_from_slice(&(v2.y as f32).to_le_bytes());
                bytes.extend_from_slice(&(v2.z as f32).to_le_bytes());

                // Attribute byte count (2 bytes)
                bytes.extend_from_slice(&0u16.to_le_bytes());
            }
        }

        bytes
    }
}
