
-- generated by elm_rs


module Generated exposing (..)

import Dict exposing (Dict)
import Http
import Json.Decode
import Json.Encode
import Url.Builder


resultEncoder : (e -> Json.Encode.Value) -> (t -> Json.Encode.Value) -> (Result e t -> Json.Encode.Value)
resultEncoder errEncoder okEncoder enum =
    case enum of
        Ok inner ->
            Json.Encode.object [ ( "Ok", okEncoder inner ) ]
        Err inner ->
            Json.Encode.object [ ( "Err", errEncoder inner ) ]


resultDecoder : Json.Decode.Decoder e -> Json.Decode.Decoder t -> Json.Decode.Decoder (Result e t)
resultDecoder errDecoder okDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map Ok (Json.Decode.field "Ok" okDecoder)
        , Json.Decode.map Err (Json.Decode.field "Err" errDecoder)
        ]


type ValueInner
    = Integer (Int)
    | Double (Float)
    | String (String)
    | Symbol (String)
    | Stl (Int)
    | List (List (ValueInner))


valueInnerDecoder : Json.Decode.Decoder ValueInner
valueInnerDecoder = 
    Json.Decode.field "t" Json.Decode.string
        |> Json.Decode.andThen
            (\tag ->
                case tag of
                    "Integer" ->
                        Json.Decode.map Integer (Json.Decode.field "c" (Json.Decode.int))
                    "Double" ->
                        Json.Decode.map Double (Json.Decode.field "c" (Json.Decode.float))
                    "String" ->
                        Json.Decode.map String (Json.Decode.field "c" (Json.Decode.string))
                    "Symbol" ->
                        Json.Decode.map Symbol (Json.Decode.field "c" (Json.Decode.string))
                    "Stl" ->
                        Json.Decode.map Stl (Json.Decode.field "c" (Json.Decode.int))
                    "List" ->
                        Json.Decode.map List (Json.Decode.field "c" (Json.Decode.list (valueInnerDecoder)))
                    unexpected ->
                        Json.Decode.fail <| "Unexpected variant " ++ unexpected
            )

type alias Evaled =
    { value : ValueInner
    , previewList : List (Int)
    }


evaledDecoder : Json.Decode.Decoder Evaled
evaledDecoder =
    Json.Decode.succeed Evaled
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "value" (valueInnerDecoder)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "preview_list" (Json.Decode.list (Json.Decode.int))))


type FromElmMessage
    = EvalLisp { code : String }
    | GetStlBytes { modelId : Int }
    | LoadFile { filePath : String }


fromElmMessageDecoder : Json.Decode.Decoder FromElmMessage
fromElmMessageDecoder = 
        let
            elmRsConstructEvalLisp code =
                        EvalLisp { code = code }
            elmRsConstructGetStlBytes modelId =
                        GetStlBytes { modelId = modelId }
            elmRsConstructLoadFile filePath =
                        LoadFile { filePath = filePath }
        in
    Json.Decode.field "type" Json.Decode.string
        |> Json.Decode.andThen
            (\tag ->
                case tag of
                    "EvalLisp" ->
                        Json.Decode.succeed elmRsConstructEvalLisp |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "code" (Json.Decode.string)))
                    "GetStlBytes" ->
                        Json.Decode.succeed elmRsConstructGetStlBytes |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "model_id" (Json.Decode.int)))
                    "LoadFile" ->
                        Json.Decode.succeed elmRsConstructLoadFile |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "file_path" (Json.Decode.string)))
                    unexpected ->
                        Json.Decode.fail <| "Unexpected variant " ++ unexpected
            )

type ToElmMessage
    = EvaluationResult { result : Result (String) (Evaled) }
    | StlBytes { modelId : Int, bytes : List (Int) }
    | FileLoaded { path : String, content : String }
    | FileLoadError { error : String }


toElmMessageDecoder : Json.Decode.Decoder ToElmMessage
toElmMessageDecoder = 
        let
            elmRsConstructEvaluationResult result =
                        EvaluationResult { result = result }
            elmRsConstructStlBytes modelId bytes =
                        StlBytes { modelId = modelId, bytes = bytes }
            elmRsConstructFileLoaded path content =
                        FileLoaded { path = path, content = content }
            elmRsConstructFileLoadError error =
                        FileLoadError { error = error }
        in
    Json.Decode.field "type" Json.Decode.string
        |> Json.Decode.andThen
            (\tag ->
                case tag of
                    "EvaluationResult" ->
                        Json.Decode.succeed elmRsConstructEvaluationResult |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "result" (resultDecoder (Json.Decode.string) (evaledDecoder))))
                    "StlBytes" ->
                        Json.Decode.succeed elmRsConstructStlBytes |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "model_id" (Json.Decode.int))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "bytes" (Json.Decode.list (Json.Decode.int))))
                    "FileLoaded" ->
                        Json.Decode.succeed elmRsConstructFileLoaded |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "path" (Json.Decode.string))) |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "content" (Json.Decode.string)))
                    "FileLoadError" ->
                        Json.Decode.succeed elmRsConstructFileLoadError |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "error" (Json.Decode.string)))
                    unexpected ->
                        Json.Decode.fail <| "Unexpected variant " ++ unexpected
            )

